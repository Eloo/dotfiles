#!/bin/bash

# Create a new directory and enter it
function md() {
	mkdir -p "$@" && cd "$@"
}


# find shorthand
function f() {
	find . -name "$1" 2>&1 | grep -v 'Permission denied'
}

# List all files, long format, colorized, permissions in octal
# function la(){
#  	ls -l  "$@" | awk '
#     {
#       k=0;
#       for (i=0;i<=8;i++)
#         k+=((substr($1,i+2,1)~/[rwx]/) *2^(8-i));
#       if (k)
#         printf("%0o ",k);
#       printf(" %9s  %3s %2s %5s  %6s  %s %s %s\n", $3, $6, $7, $8, $5, $9,$10, $11);
#     }'
#}

# cd into whatever is the forefront Finder window.
cdf() {  # short for cdfinder
  cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}



# git commit browser. needs fzf
log() {
  git log --graph --color=always \
      --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
  fzf --ansi --no-sort --reverse --tiebreak=index --toggle-sort=\` \
      --bind "ctrl-m:execute:
                echo '{}' | grep -o '[a-f0-9]\{7\}' | head -1 |
                xargs -I % sh -c 'git show --color=always % | less -R'"
}



# Start an HTTP server from a directory, optionally specifying the port
function server() {
	local port="${1:-8000}"
	open "http://localhost:${port}/" &
	# statik is good because it won't expose hidden folders/files by default.
	# npm install -g statik
	statik --port "$port" .
}

function extract_filename(){
	FILENAME="${1%.*}"
	echo $FILENAME
}

function tox264(){
	FILENAME="${1%.*}"
	avconv -i $1 -c:v libx264 -crf 19 -preset veryslow -c:a copy $FILENAME.mkv
	chmod 644 $FILENAME.mkv
}


# Copy w/ progress
cp_p () {
  rsync -WavP --human-readable --progress $1 $2
}



# get gzipped size
function gz() {
	echo "orig size    (bytes): "
	cat "$1" | wc -c
	echo "gzipped size (bytes): "
	gzip -c "$1" | wc -c
}

# whois a domain or a URL
function whois() {
	local domain=$(echo "$1" | awk -F/ '{print $3}') # get domain from URL
	if [ -z $domain ] ; then
		domain=$1
	fi
	echo "Getting whois record for: $domain â€¦"

	# avoid recursion
					# this is the best whois server
													# strip extra fluff
	/usr/bin/whois -h whois.internic.net $domain | sed '/NOTICE:/q'
}

# preview csv files. source: http://stackoverflow.com/questions/1875305/command-line-csv-viewer
function csvpreview(){
      sed 's/,,/, ,/g;s/,,/, ,/g' "$@" | column -s, -t | less -#2 -N -S
}

# Extract archives - use: extract <file>
# Based on http://dotfiles.org/~pseup/.bashrc
function extract() {
	if [ -f "$1" ] ; then
		local filename=$(basename "$1")
		local foldername="${filename%%.*}"
		local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
		local didfolderexist=false
		if [ -d "$foldername" ]; then
			didfolderexist=true
			read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
			echo
			if [[ $REPLY =~ ^[Nn]$ ]]; then
				return
			fi
		fi
		mkdir -p "$foldername" && cd "$foldername"
		case $1 in
			*.tar.bz2) tar xjf "$fullpath" ;;
			*.tar.gz) tar xzf "$fullpath" ;;
			*.tar.xz) tar Jxvf "$fullpath" ;;
			*.tar.Z) tar xzf "$fullpath" ;;
			*.tar) tar xf "$fullpath" ;;
			*.taz) tar xzf "$fullpath" ;;
			*.tb2) tar xjf "$fullpath" ;;
			*.tbz) tar xjf "$fullpath" ;;
			*.tbz2) tar xjf "$fullpath" ;;
			*.tgz) tar xzf "$fullpath" ;;
			*.txz) tar Jxvf "$fullpath" ;;
			*.zip) unzip "$fullpath" ;;
			*) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
		esac
	else
		echo "'$1' is not a valid file"
	fi
}

# who is using the laptop's iSight camera?
camerausedby() {
	echo "Checking to see who is using the iSight cameraâ€¦ ðŸ“·"
	usedby=$(lsof | grep -w "AppleCamera\|USBVDC\|iSight" | awk '{printf $2"\n"}' | xargs ps)
	echo -e "Recent camera uses:\n$usedby"
}


# animated gifs from any video
# from alex sexton   gist.github.com/SlexAxton/4989674
gifify() {
  if [[ -n "$1" ]]; then
	if [[ $2 == '--good' ]]; then
	  ffmpeg -i "$1" -r 10 -vcodec png out-static-%05d.png
	  time convert -verbose +dither -layers Optimize -resize 900x900\> out-static*.png  GIF:- | gifsicle --colors 128 --delay=5 --loop --optimize=3 --multifile - > "$1.gif"
	  rm out-static*.png
	else
	  ffmpeg -i "$1" -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=3 > "$1.gif"
	fi
  else
	echo "proper usage: gifify <input_movie.mov>. You DO need to include extension."
  fi
}

# turn that video into webm.
# brew reinstall ffmpeg --with-libvpx
webmify(){
	ffmpeg -i "$1" -vcodec libvpx -acodec libvorbis -isync -copyts -aq 80 -threads 3 -qmax 30 -y "$2" "$1.webm"
}

# direct it all to /dev/null
function nullify() {
  "$@" >/dev/null 2>&1
}


# visual studio code. a la `subl`
function code () { VSCODE_CWD="$PWD" open -n -b "com.microsoft.VSCodeInsiders" --args $*; }

# `shellswitch [bash |zsh]`
#   Must be in /etc/shells
shellswitch () {
	chsh -s $(brew --prefix)/bin/$1
}

# create directory and enter it
function mkcd () {
    mkdir -p "$*"
    cd "$*"
}

# Override antigen-selfupdate
function antigen-selfupdate(){
	wget 'https://raw.githubusercontent.com/zsh-users/antigen/develop/bin/antigen.zsh' -O ~/dotfiles/antigen.zsh.tmp
	mv ~/dotfiles/antigen.zsh.tmp ~/dotfiles/antigen.zsh
	source ~/dotfiles/antigen.zsh
}

# Removes audio tracks from mkv files
# see https://www.reddit.com/r/usenet/comments/2ofcv5/remove_unwanted_audiosubtitles_from_mkv/
function mkv_remove_audio(){
	find -iname '*.mkv' -type f -exec ~/dotfiles/helpers/mkvmerge-remove-atracks.awk {} "$@" \;
}

# Apply distorion filter using ffmpeg
function distorion_filter(){
	SEARCH_STRING="*.*"
	if [ -z "$1" ]
	  	then
	    	echo "Process all files"
	    else
			echo "Process all files with the extension '$1'"
			SEARCH_STRING="*.$1"
	fi
	find . -type f -iname $SEARCH_STRING | while read LINE; do
    	INPUT_FILE=$LINE
    	echo "Processing file '$INPUT_FILE'"
    	DIR=$(dirname "$INPUT_FILE")
    	EXTENSION=${INPUT_FILE##*.}
    	MIME_TYPE=`exiftool $INPUT_FILE | grep MIME | awk '{print $4}'`
    	OUTPUT_ARGS=""
		if [[ $MIME_TYPE =~ "image/*" ]]
			then
				echo "Handle image"
		    	FILE_TYPE=`exiftool $INPUT_FILE | grep "File Type Extension" | awk '{print $5}'`
		    	echo $FILE_TYPE
				OUTPUT_ARGS="-vcodec $FILE_TYPE"
		fi

    	FILENAME="${INPUT_FILE%.*}"_distortion
    	OUTPUT_FILE="$FILENAME."$EXTENSION
    	ffmpeg -i $INPUT_FILE  -vf "lenscorrection=cx=0.5:cy=0.5:k1=-0.227:k2=-0.022" -crf 17 -q:v 0 -map_metadata 0 $OUTPUT_FILE < /dev/null
    	touch -r $INPUT_FILE $OUTPUT_FILE
	done
	
}

function disk-backup(){
	target_name=$2.$(date +%Y-%m-%d_%H-%M-%S).img.gz
	echo "Create backup of $1 to $target_name"
	pipe="cat"
	if hash pv 2>/dev/null; then
		pipe=pv
	fi
	sudo dd if=$1 conv=sync,noerror bs=64K | $pipe | gzip -c  > $target_name
	echo "Backup created at $target_name"
}

function disk-restore(){
	echo "Restore image $1 to $2"
	pipe="cat"
	if hash pv 2>/dev/null; then
		pipe=pv
	fi
	sudo gunzip -c $1 | $pipe | sudo dd of=$2 conv=sync,noerror bs=64K
}

function speed_test_1gb(){
	pipe="cat"
	dd_status="status=progress"
	if hash pv 2>/dev/null; then
		pipe=(pv -s 1g)
		dd_status="status=none"
	fi
	echo "Test write speed"
	dd if=/dev/zero bs=1M count=1024 conv=notrunc status=none | $pipe | dd of=tempfile conv=fdatasync $dd_status
	echo "Drop caches"
	echo 3 | sudo tee /proc/sys/vm/drop_caches > /dev/null
	echo "Test read speed uncached"
	dd if=tempfile  bs=1M count=1024 $dd_status | $pipe | dd of=/dev/null status=none
	echo "Test read speed cached"
	dd if=tempfile  bs=1M count=1024 $dd_status | $pipe | dd of=/dev/null status=none
	echo "Delete tmp file"
	rm tempfile
}

function count_extensions () {
	find $1 -type f | grep -E ".*\.[a-zA-Z0-9]*$" | sed -e 's/.*\(\.[a-zA-Z0-9]*\)$/\1/' | sort | uniq -c | sort -nr
}

# Kill intellij prozesses
function kill_intellij () {
	ps -ef | grep -i intellij | awk 'NR > 1 { print prev } { prev = $2 }' | xargs kill -9
}

function echo_server (){
	if hash http-echo-server 2>/dev/null; then
		if [ $# -eq 1 ]
  then
    export PORT=$1
	fi
		http-echo-server
	else
		echo "http-echo-server seems not be installed. You can install it using 'npm install http-echo-server -g'."
	fi
}

# Fetch http status code description
function httpstatuscode(){
	curl -s http://www.ietf.org/assignments/http-status-codes/http-status-codes.txt | grep "$1" | head -1
}
